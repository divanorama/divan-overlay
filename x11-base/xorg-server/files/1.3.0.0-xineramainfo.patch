diff -ruw xorg-server-1.3.0.0-org/hw/xfree86/common/xf86Config.c xorg-server-1.3.0.0/hw/xfree86/common/xf86Config.c
--- xorg-server-1.3.0.0-org/hw/xfree86/common/xf86Config.c	2006-12-01 02:40:10.000000000 +0100
+++ xorg-server-1.3.0.0/hw/xfree86/common/xf86Config.c	2008-03-19 18:10:52.000000000 +0100
@@ -767,6 +767,7 @@
     FLAG_ESTIMATE_SIZES_AGGRESSIVELY,
     FLAG_NOPM,
     FLAG_XINERAMA,
+    FLAG_XINERAMAINFO,
     FLAG_ALLOW_DEACTIVATE_GRABS,
     FLAG_ALLOW_CLOSEDOWN_GRABS,
     FLAG_LOG,
@@ -832,6 +833,8 @@
 	{0}, FALSE },
   { FLAG_XINERAMA,		"Xinerama",			OPTV_BOOLEAN,
 	{0}, FALSE },
+  { FLAG_XINERAMAINFO,		"XineramaInfo",			OPTV_STRING,
+	{0}, FALSE },
   { FLAG_ALLOW_DEACTIVATE_GRABS,"AllowDeactivateGrabs",		OPTV_BOOLEAN,
 	{0}, FALSE },
   { FLAG_ALLOW_CLOSEDOWN_GRABS, "AllowClosedownGrabs",		OPTV_BOOLEAN,
@@ -1124,8 +1127,48 @@
       noPanoramiXExtension = !value;
       from = X_CONFIG;
     }
-    if (!noPanoramiXExtension)
+    if (1 || !noPanoramiXExtension) {
+      const char *s;
       xf86Msg(from, "Xinerama: enabled\n");
+      if ((s = xf86GetOptValString(FlagOptions, FLAG_XINERAMAINFO))) {
+	char *b=s;
+	xf86Msg(X_CONFIG, "XineramaInfo: \"%s\"\n", s);
+	do {
+	  char *t=0, *p1=0, *p2=0;
+	  t=index(b,'x');
+	  if(t) {
+	    t++;
+	    p1=index(t,'+');
+	    if(p1) {
+	      p1++;
+	      p2=index(p1,'+');
+	      if(p2) {
+		p2++;
+		if(XineramaInfoScreensNum<16) {
+		  XineramaInfoScreensGeometry[XineramaInfoScreensNum][0]=atoi(b);
+		  XineramaInfoScreensGeometry[XineramaInfoScreensNum][1]=atoi(t);
+		  XineramaInfoScreensGeometry[XineramaInfoScreensNum][2]=atoi(p1);
+		  XineramaInfoScreensGeometry[XineramaInfoScreensNum][3]=atoi(p2);
+		  XineramaInfoScreensNum++;
+		};
+	      };
+	    };
+	  };
+	  b=index(b,',');
+	  if(b) b++;
+	} while(b);
+	do {
+	  int i;
+	  for(i=0;i<XineramaInfoScreensNum;i++) {
+	    xf86Msg(X_CONFIG, "  screen %i: w=%i h=%i x=%i y=%i\n", i,
+		    XineramaInfoScreensGeometry[i][0],
+		    XineramaInfoScreensGeometry[i][1],
+		    XineramaInfoScreensGeometry[i][2],
+		    XineramaInfoScreensGeometry[i][3]);
+	  };
+	} while(0);
+      };
+    };
 #endif
 
     return TRUE;
diff -ruw xorg-server-1.3.0.0-org/include/globals.h xorg-server-1.3.0.0/include/globals.h
--- xorg-server-1.3.0.0-org/include/globals.h	2006-09-18 08:04:18.000000000 +0200
+++ xorg-server-1.3.0.0/include/globals.h	2008-03-19 18:31:21.000000000 +0100
@@ -49,6 +49,8 @@
 extern Bool PanoramiXWindowExposureSent;
 extern Bool PanoramiXOneExposeRequest;
 extern Bool PanoramiXExtensionDisabledHack;
+extern int XineramaInfoScreensNum;
+extern int XineramaInfoScreensGeometry[16][4];
 #endif
 
 #ifdef BIGREQS
diff -ruw xorg-server-1.3.0.0-org/Xext/panoramiX.c xorg-server-1.3.0.0/Xext/panoramiX.c
--- xorg-server-1.3.0.0-org/Xext/panoramiX.c	2006-09-18 08:04:17.000000000 +0200
+++ xorg-server-1.3.0.0/Xext/panoramiX.c	2008-03-19 18:33:25.000000000 +0100
@@ -58,6 +58,8 @@
 #endif
 #include "modinit.h"
 
+int XineramaInfoScreensNum;
+int XineramaInfoScreensGeometry[16][4];
 
 #ifdef GLXPROXY
 extern VisualPtr glxMatchVisual(ScreenPtr pScreen,
@@ -1047,7 +1049,11 @@
     {
 	/* The following hack fools clients into thinking that Xinerama
 	 * is disabled even though it is not. */
+#if 0
 	rep.state = !noPanoramiXExtension && !PanoramiXExtensionDisabledHack;
+#else
+	rep.state = (!noPanoramiXExtension && !PanoramiXExtensionDisabledHack) || (XineramaInfoScreensNum!=0);
+#endif
     }
 #else
     rep.state = !noPanoramiXExtension;
@@ -1071,6 +1077,72 @@
 
     REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
 
+#if 0
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.number = (noPanoramiXExtension) ? 0 : PanoramiXNumScreens;
+    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
+    if (client->swapped) {
+	register int n;
+	swaps (&rep.sequenceNumber, n);
+	swapl (&rep.length, n);
+	swapl (&rep.number, n);
+    }	
+    WriteToClient (client, sizeof (xXineramaQueryScreensReply), (char *) &rep);
+
+    if(!noPanoramiXExtension) {
+	xXineramaScreenInfo scratch;
+	int i;
+
+	for(i = 0; i < PanoramiXNumScreens; i++) {
+	    scratch.x_org  = panoramiXdataPtr[i].x;
+	    scratch.y_org  = panoramiXdataPtr[i].y;
+	    scratch.width  = panoramiXdataPtr[i].width;
+	    scratch.height = panoramiXdataPtr[i].height;
+	
+	    if(client->swapped) {
+		register int n;
+		swaps (&scratch.x_org, n);
+		swaps (&scratch.y_org, n);
+		swaps (&scratch.width, n);
+		swaps (&scratch.height, n);
+	    }
+	    WriteToClient (client, sz_XineramaScreenInfo, (char *) &scratch);
+	}
+    }
+#else
+    if(XineramaInfoScreensNum!=0) {
+      xXineramaScreenInfo scratch;
+      int i;
+      rep.type = X_Reply;
+      rep.sequenceNumber = client->sequence;
+      rep.number = XineramaInfoScreensNum;
+      rep.length = rep.number * sz_XineramaScreenInfo >> 2;
+      if (client->swapped) {
+	register int n;
+	swaps (&rep.sequenceNumber, n);
+	swapl (&rep.length, n);
+	swapl (&rep.number, n);
+      }	
+      WriteToClient (client, sizeof (xXineramaQueryScreensReply), (char *) &rep);
+      
+      for(i = 0; i < XineramaInfoScreensNum; i++) {
+	scratch.x_org  = XineramaInfoScreensGeometry[i][2];
+	scratch.y_org  = XineramaInfoScreensGeometry[i][3];
+	scratch.width  = XineramaInfoScreensGeometry[i][0];
+	scratch.height = XineramaInfoScreensGeometry[i][1];
+	
+	if(client->swapped) {
+	  register int n;
+	  swaps (&scratch.x_org, n);
+	  swaps (&scratch.y_org, n);
+	  swaps (&scratch.width, n);
+	  swaps (&scratch.height, n);
+	}
+	WriteToClient (client, sz_XineramaScreenInfo, (char *) &scratch);
+      }
+    }
+    else {
     rep.type = X_Reply;
     rep.sequenceNumber = client->sequence;
     rep.number = (noPanoramiXExtension) ? 0 : PanoramiXNumScreens;
@@ -1103,6 +1175,8 @@
 	    WriteToClient (client, sz_XineramaScreenInfo, (char *) &scratch);
 	}
     }
+    };
+#endif
 
     return client->noClientException;
 }
